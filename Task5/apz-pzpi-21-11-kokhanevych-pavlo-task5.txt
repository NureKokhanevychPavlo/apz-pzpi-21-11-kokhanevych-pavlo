1 ОПИС  ПРИЙНЯТИХ ІНЖЕНЕРНИХ РІШЕНЬ

Мобільний додаток містить функціонал, який призначений для звичайного клієнта даної програмної системи. Враховуючи обмежені ресурси мобільних пристроїв, було прийнято рішення використовувати виключно технології, які були створенні для мобільних телефонів, щоб краще керувати ресурсами.
Для створення даного додатку було використано середовище розробки Android Studio та мова програмування Kotlin для забезпечення її широкої функціональності.  Для полегшення безперешкодної комунікації з серверною частиною ми включили бібліотеку Retrofit, що дозволяє без зусиль надсилати та отримувати запити від сервера за специфікацією REST API.
З точки зору безпеки та зручності користувача, додаток використовує токен авторизації, згенерований JWT, який надійно зберігається в загальних налаштуваннях на пристрої користувача. Такий підхід гарантує безпечне та надійне зберігання важливої інформації про авторизацію, що підвищує загальну безпеку додатку.
Мобільний додаток використовує технології для забезпечення зменшення залежностей між класами та шарами програми, а саме Hilt. Це бібліотека для впровадження залежностей в додатках, розроблена Google. Hilt забезпечує простіший та структурований підхід до управління залежностями, використовуючи на основі Dagger 2. Ця бібліотека інтегрується з компонентами Android і сприяє кращому управлінню життєвим циклом об'єктів. Його реалізація вимагала створення окремої файлової структури для створення модулів, які містять логіку ініціалізації об’єктів при їх використанні в програмі. Використання даної технології дозволило зменшити необхідність слідкувати та контролювати залежності під час написання коду.
У даному мобільному додатку було використано Kotlin Coroutines для ефективного управління асинхронними операціями. Вони забезпечують спрощену і більш читабельну обробку асинхронних завдань у порівнянні з традиційними підходами, такими як RxJava. Вони дозволяють писати код асинхронно, який виглядає як синхронний, значно зменшуючи обсяг шаблонного коду і ризик помилок. Завдяки структурі Coroutines, код виглядає чистіше і його легше підтримувати.
 Користувацький інтерфейс визначається за допомогою XML-файлів, що забезпечує чітку структурованість та легкість підтримки. Використання таких типів файлів для опису  дозволяє відокремити логіку програми від візуального представлення, що сприяє кращій організації коду та полегшує внесення змін до дизайну без необхідності модифікації програмного коду. Вони зберігаються в директорії “res/layout”. Кожен XML-файл відповідає за дизайн одного екрану або частини екрану.
Програмне забезпечення складається із трьох логічних архітектурних шарів, які забезпечують можливість масштабувати та підтримувати його функціональність без втрати великої кількості часу. Чиста архітектура є однією з ключових архітектурних парадигм, яка була використана у мобільному додатку. Вона забезпечує чітке розділення відповідальностей між різними частинами програми, що сприяє легкості тестування, розширюваності та підтримки коду . В проекті реалізовано три основні шари: модель, домен та інтерфейс користувача.
Шар моделі відповідає за доступ до даних та їхню обробку. Він включає класи, які взаємодіють з базами даних, мережевими сервісами та іншими джерелами даних. Основною метою цього шару є ізоляція джерел даних від решти програми, що забезпечує більшу гнучкість та зменшує зв'язність між компонентами. Для даного проекту він містить основні об’єкти та класи для взаємодії із серверною частиною. Він складається із сутностей, які створенні для зберігання інформації із сервера та формуванню об’єктів для передачі даних. Також наявні репозиторії, які виконують операції із даними та містять конкретну реалізацію логіки обробки. Його репозиторії залежать від абстракцій, які реалізовані в шарі домен.
Шар домена є серцем додатку і містить бізнес-логіку. Він незалежний від конкретних реалізацій джерел даних або способів представлення даних, що робить його більш тестованим та стабільним до змін. Взаємодія між шаром домена та іншими шарами відбувається через інтерфейси. Шар домена не знає про конкретні реалізації джерел даних, що дозволяє легко змінювати або розширювати їх без впливу на бізнес-логіку. В даному додатку цей шар містить інтерфейси, які визначають основну логіку репозиторіїв та додатку. Також присутні об’єкти для передачі даних, які зменшують залежність для інших шарів даної програми. Існує окрема структура файлів для визначення певних випадків користування для шару відображення даних. Тобто кожна функціональна можливість системи містить свій клас для забезпечення контролю між потоками.
Шар інтерфейсу користувача відповідає за відображення даних і взаємодію з користувачем. Він включає Activity, Fragment, ViewModel та інші компоненти, які забезпечують користувацький досвід. Даний шар взаємодіє із шаром доменом для отримання необхідної функціональності та даних, щоб максимально зменшити залежність від шару доступу до даних. Саме тут відбувається логіка, яка відповідає за відображення графічних елементів та їх взаємодія один із одним. Навігація між компонентами даного шару відбувається за допомогою спеціального графа, який містить всю інформацію про їхню наявність та  можливу взаємодію.
Для покращення чистоти коду був використаний шаблон проектування Model-View-ViewModel (MVVM). Цей шаблон дозволяє чітко розділити відповідальності між різними компонентами, що сприяє кращій організації коду. ViewModel є мостом між View та Model. Він отримує дані з Model через доменний шар і підготовлює їх для відображення у View. ViewModel також обробляє події від View, керуючи бізнес-логікою, яка не залежить від специфічного відображення. Використання ViewModel дозволяє зменшити залежність між View та Model, роблячи код більш модульним та легшим для тестування.

2 ПОБУДОВА ДІАГРАМИ КОМПОНЕНТІВ ТА ДІЯЛЬНОСТІ

Побудова діаграми компонентів - це процес візуалізації архітектури програмної системи або проекту, розбитого на окремі компоненти та їх зв'язки.
Спочатку потрібно визначити всі компоненти системи. Компонент може бути будь-яким логічним або фізичним модулем, що виконує певну функцію. Оскільки програмна система складається із кількох програм, то можна виділити основні компоненти, такі як: серверна частина, база даних, мобільний застосунок, пристрій, Front-частина. Всі вони поділяються на певні логічні компоненти, які пов’язані між собою інтерфейсами та дозволяють розширювати систему.
Серверна частина містить в собі кілька логічних компонентів, а саме: доступ до даних (data), бізнес-логіка (business logic), представлення (presentation). Кожен із них виконує свою роботу в межах серверної частини. Потрібно виділити, що бізнес-логіка використовує компонент доступу до даних за допомогою інтерфейсів репозиторіїв. Тобто він використовує “IRepo” для комунікації. Також бізнес-логіка використовує зовнішні компоненти, такі як: Stripe API та Dropbox API. Компонент представлення використовує бізнес-логіку використовуючи інтерфейси сервісів “IService”. Сервер взаємодіє із базою даних, що також являє собою компонентом, використовуючи JDBC.
Мобільний застосунок взаємодіє із серверною частиною за допомогою  “IMobile”. Цей компонент також складається із декількох логічних компонентів, такі як: доступ до даних (data), абстракція (domain), представлення (presentation). Доступ до даних та представлення використовують абстракції використовуючи інтерфейси репозиторіїв.
Front-частина також взаємодіє із серверною частиною через протоколи HTTP. Даний компонент містить кілька логічних компонентів: Components, UI elements. Вони працюють один із одним через інтерфейси компонентів “IComponents”.
IoT пристрій відіграє роль фізичного компонента системи, який також взаємодія із сервером через мережеві протоколи. Згідно опису структури компонентів та їх взаємодії була побудована діаграма компонентів (див. рис. 2.1).


Рисунок 2.1 - Діаграма компонентів (Component Diagram)

Діаграма діяльності (Activity Diagram) в UML є ефективним інструментом для моделювання процесів в IoT програмах. Вона допомагає візуалізувати потік управління між різними діями та рішеннями в системі. Спираючись на принцип побудови такої діаграми для IoT програми, що включає два основних випадки: отримання даних про стан та задання даних про стан, була побудована візуальна діаграма (див. рис. 2.2). 
Позначення стартового стану за допомогою "Initial Node" (чорний заповнений кружечок). Це позначає початок процесу в IoT програмі.
Після стартового стану слідує рішення, яке визначає подальший хід подій. Цей вузол рішення позначається ромбом. З рішення виходять дві стрілки, які ведуть до різних дій. Перша стрілка веде до дії "Отримати дані про стан". "Отримати дані про стан" позначається прямокутником (Activity Node), який описує процес отримання даних від IoT пристроїв. Це може включати зчитування сенсорних даних, отримання стану акторів або будь-яких інших даних від пристроїв.


Рисунок 2.2 - Діаграма діяльності (Component Diagram)

3 ПОБУДОВА ДІАГРАМИ ПРЕЦЕДЕНТІВ

Предметна область містить три типи користувачів на яких система має спиратися та реалізовувати свою функціональність залежно від потреб таких користувачів як клієнти, тобто власники тварин, адміністратор бази даних та адміністратор, який відповідає за бізнес-логіку системи. Кожен тип користувача має свій набір чітких функціональних потреб до продукту. 
Клієнт або власник тварини є основним типом користувача для даної предметної області, який повинен мати базові функції перегляду інформації та можливості з нею працювати та змінювати. Власник тварини може мати змогу переглянути інформацію про готелі, кімнати, обрати вільні кімнати, переглянути минулі оренди та поточні. Оскільки програмна система повинна мати певні способи монетизації, то клієнт зможе орендувати певну кімнату в певний період, щоб отримати доступ  до панелі контролю кімнати на період оренди. Така функціональність вимагає заповнення форми для надання інформаціє про тварину, номер картки, термін оренди. Зворотній зв’язок необхідний для користувача, щоб терміново повідомити про певні проблеми з його твариною. Перегляд власних тварин та їх додавання та редагування в системі, необхідна функція, щоб полегшити процес контролю та реєстрації тварини до системи. Кожен клієнт буде мати змогу редагувати свій власний профіль.
Описані функціональні потреби повністю характеризують необхідні функції для власника тварини та представленні у вигляді діаграми прецедентів (див. рис. 3.1).


Рисунок 3.1 – Діаграма прецедентів для клієнтів

Функціональні потреби адміністратора бази даних спираються на можливостях роботи бази даних та забезпечення цілісності даних, щоб керувати інформаційним змістом системи та сприяти її захисту. Даний вид адміністраторів має потребу переглядати всю інформацію, яка зберігається в системі про користувачів, тварин, оренди, кімнат та інші сутності, які наявні в системі. 
Оскільки адміністратор повинен не лише спостерігати за наявними даними, а й працювати з ними, тому він матиме потребу редагувати, видаляти, додавати різні види інформації. Бази даних зазвичай мають резервні копії, щоб уникнути ризику втрати інформації, тому функції резервного копіювання та відновлення системи після можливої аварії обов’язково мають бути в наявності даного адміністратора. Для візуалізації описаних функцій адміністратора бази даних було створено діаграму прецедентів для даного типу користувачів (див. рис. 3.2).

Рисунок 3.2 - Діаграма прецедентів для адміністратора бази даних

Останній вид користувачів це адміністратори бізнес-логіки програмної системи. Функціональні потреби даних адміністраторів спираються на контролі різних видів інформації та формування статистик, щодо роботи програмної системи загалом.  Всі функціональні потреби, які були описані для даного користувача,  представлені у вигляді діаграми прецедентів (див. рис. 3.3).


Рисунок 3.3 - Діаграма прецедентів для адміністратора бізнес-логіки

Даний вид адміністраторів буде мати можливість формувати статистику заробітку готелю в певний період часу, що дозволяє визначити доцільність витрат та стан певного готелю. Також присутня можливість визначати середню тривалість оренди кімнати, що дозволяє формувати нові бізнес-вимоги.
Система повинна надавати можливості реєстрації та автентифікації, оскільки дана функціональність характерна для всіх видів користувачів, то було прийняте рішення виділити даний функціонал на окремій діаграмі прецедентів (див. рис. 3.4).


Рисунок 3.4 – Діаграма прецедентів для неавторизованих користувачів

Під час формування діаграм прецедентів було виділено основні види користувачів для даної програмної системи та їхній функціонал, який був описаний, а також представлений у вигляді діаграм прецедентів.

ВИСНОВКИ

Під час виконання лабораторної роботи була розроблена мобільна частина програмної системи із необхідним функціональними потребами. 
ДОДАТОК А
Основний код бізнес-логіки

RetrofitUserSource
1 @Singleton
2 class RetrofitUserSource @Inject constructor(
3     private val userApi: UserApi
4 ): ExceptionHandler(), UserSource {
5
6     override suspend fun getPresentUser(email: String): User = wrapRetrofitExceptions {
7         userApi.getPresentUser(email).toUser()
8     }
9
10     override suspend fun getUserPhoto(userId: Int): ByteArray? = wrapRetrofitExceptions {
11         try {
12             val response = userApi.getUserPhoto(userId)
13             if (response.isSuccessful && response.body() != null) {
14                 response.body()?.bytes()
15             } else {
16                 null
17             }
18         } catch (e: Exception) {
19             e.printStackTrace()
20             null
21         }
22     }
23
24     override suspend fun deleteUser(userId: Int) = wrapRetrofitExceptions {
25         userApi.deleteUser(userId)
26     }
27
28
29     override suspend fun saveUser(user: User, photoLink: String?) = wrapRetrofitExceptions {
30         val gson = GsonBuilder()
31             .registerTypeAdapter(LocalDate::class.java, LocalDateConverter())
32             .create()
33
34         val userJson = gson.toJson(user)
35         val userRequestBody = RequestBody.create(MediaType.parse(RetrofitAuthenticationSource.JSON_TYPE_MEDIA), userJson)
36         val body = MultipartBody.Part.createFormData(RetrofitAuthenticationSource.USER, null, userRequestBody)
37         userApi.saveUser(body, createMultipartFromUri(photoLink ?: ""))
38     }
39
40     private fun createMultipartFromUri(selectedImageUri: String): MultipartBody.Part? {
41         val file = File(selectedImageUri)
42         if (!file.exists()) {
43             Log.e("File Error", "File does not exist: $selectedImageUri")
44             return null
45         }
46         val requestFile = RequestBody.create(MultipartBody.FORM, file)
47         val bodyTest = MultipartBody.Part.createFormData(RetrofitAuthenticationSource.PHOTO, file.name, requestFile)
48
49         return bodyTest
50     }
51
52     override suspend fun getPetsOfUser(userId: Int): Flow<List<Pet>> = wrapRetrofitExceptions {
53         val pets = userApi.getPetsOfUser(userId).map { it.toPet() }
54         flowOf(pets)
55     }
56
57     override suspend fun addPetsOfUser(listOfPets: List<Pet>) = wrapRetrofitExceptions {
58         userApi.addPetsOfUser(listOfPets.map { PetEntity.toPetEntity(it)})
59     }
60
61     override suspend fun getHistoryRenting(userId: Int): Flow<List<HistoryRentingResponse>> = wrapRetrofitExceptions {
62         val historyRentingResponse = userApi.getHistoryRenting(userId).map { it.toHistoryRentingResponse()}
63         flowOf(historyRentingResponse)
64     }
65
66     override suspend fun getAllHotels(): Flow<List<Hotel>> = wrapRetrofitExceptions {
67         val hotels = userApi.getAllHotels().map { it.toHotel() }
68         flowOf(hotels)
69     }
70
71     override suspend fun getRoomsByHotel(hotelId: Int): Flow<List<Room>> = wrapRetrofitExceptions {
72         flowOf(userApi.getRoomsByHotel(hotelId).map { it.toRoom() })
73     }
74
75     override suspend fun addNewRentingForUser(listOfSchedules: List<Schedule>) = wrapRetrofitExceptions {
76         userApi.addNewRentingForUser(listOfSchedules.map { ScheduleEntity.toScheduleEntity(it) })
77     }
78
79     override suspend fun getAllFreeRoomByPeriod(hotelId: Int, dateRequest: DateRequest): Flow<List<Room>> = wrapRetrofitExceptions {
80         flowOf(userApi.getAllFreeRoomByPeriod(hotelId, DateRequestEntity.toDateRequestEntity(dateRequest)).map { it.toRoom() })
81     }
82
83     override suspend fun sendMessageToAdmin(userId: Int, message: String)  = wrapRetrofitExceptions {
84         userApi.sendMessageToAdmin(userId, message)
85     }
86
87     override suspend fun autogenerateSchedule(autogenerateRequest: AutogenerateRequest): Flow<List<ScheduleFeedResponse>> = wrapRetrofitExceptions {
88         flowOf(userApi.autogenerateSchedule( AutogenerateRequestEntity.toAutogenerateRequestEntity(autogenerateRequest)).map { it.toScheduleFeedResponse() })
89     }
90
91     override suspend fun getRoomById(roomId: Int): List<Room>  = wrapRetrofitExceptions {
92         userApi.getRoomById(roomId).map { it.toRoom() }
93     }
94
95     override suspend fun getScheduleFeed(rentId: Int): List<ScheduleFeedResponse> = wrapRetrofitExceptions {
96         userApi.getScheduleFeed(rentId).map { it.toScheduleFeedResponse() }
97     }
98
99     override suspend fun updateTimeOfScheduleFeed(listOfResponseSchedule: List<ScheduleFeedResponse>) = wrapRetrofitExceptions {
100         userApi.updateTimeOfScheduleFeed(listOfResponseSchedule.map { ScheduleFeedResponseEntity.toScheduleFeedResponseEntity(it) })
101     }
102
103     companion object {
104         private const val USER = "user"
105         private const val PHOTO = "photo"
106         private const val JSON_TYPE_MEDIA = "application/json"
107     }
108 }
