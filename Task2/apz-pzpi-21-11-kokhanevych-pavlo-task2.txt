1 ОПИС АРХІТЕКТУРИ СИСТЕМИ

Архітектура системи для контролю за домашніми тваринами в спеціальному готелі для тварин складається із кількох окремих програмних частин, які взаємодіють між собою та забезпечують ефективну роботу працюючи на різних технологіях та стилях.
 Поточна система включає в себе серверну частину, яка містить основну бізнес-логіку, яка пов’язана із математичними операціями визначення графіку харчування, валідації даних, обробка різних типів помилок, взаємозв’язок із зовнішніми API та методи для обробки та зберігання даних в незалежній базі даних, а також API, щоб інші компоненти змогли взаємодіяти з нею. Сервер використовує контролери для отримання різних типів інформації та її обробку. Серверна частина забезпечує контроль доступу для кількох типів користувачів, а також  для IoT частин. Також проводиться резервування даних кожного дня для уникнення ризику втрати даних.
 Мобільна та Front-частина містять методи для взаємодії із сервером, а також логіку відображення даних та функцій, які були передбаченні системою.
Поточні частини системи надають зручний інтерфейс для клієнтів для реєстрації, бронювання, спілкування з готелем та інших операцій. Вони надають можливість локалізації, інтернаціоналізації та адміністрування Забезпечується також безпека даних користувачів, автентифікація, а також захист приватності даних під час взаємодії із сервісною частиною.
 IoT частина складається із набору датчиків для контролю температури, вологості, світла, блоків із їжею та камерою.  Вони з’єднанні до одного комп’ютера, який обробляє інформацію, збирає статистику та відправляє на сервер для подальшої роботи, а також надає методи для контролю показників датчиків та відео зв’язок. 
Всі компоненти системи використовують REST API для забезпечення гнучкої взаємодії між собою. Використання Spring Security з JWT та хешування даних  для автентифікації та авторизації допомагає забезпечити безпеку системи. Наявність функцій створення резервних копій та відновлення даних дозволяє швидко відновлювати систему в разі аварійних ситуацій або втрати даних. Архітектура має розподілену структуру на різні слої для кожної програми, що дозволяє гнучко розширювати та масштабувати систему. Кожен окремий компонент може бути масштабований незалежно від інших, що сприяє горизонтальному та вертикальному масштабуванню. 

2 ПОБУДОВА ДІАГРАМИ РОЗГОРТАННЯ

Діаграма розгортання створюється із метою описати структуру та взаємозв'язки компонентів програмної системи для контролю за тваринами у спеціальному готелі для тварин. Вона також відображає фізичну архітектуру системи, включаючи розташування апаратних та програмних ресурсів.
Враховуючи поточні вимоги до системи, то діаграма (див. рис. 2.1) містить чотири основні компоненти, які при взаємодії один із одним формують програмну систему. 
Основним фізичним компонентом системи потрібно виділити сервер на якому буде відбуватися бізнес-логіка та виконуватися складні обчислення.
Сервер є центральним елементом програмної системи для контролю за тваринами у готелі. Фізично він має розміщуватися на потужному сервері з високими характеристиками продуктивності та надійності. Сервер виконує функції зберігання, обробки та управління даними, обчислення графіків харчування та перевірку даних про тварин і їх власників. Даний пристрій працює на фреймворку Spring Boot, який підтримує функціональність програми.
Використовуючи TCP/IP, він спілкується із базою даних, яка знаходиться на незалежному фізичному пристрої, який містить систему управління базами даних MySQL.  База даних використовується для зберігання інформації про тварин, господарів, оренду, адреса та графіки харчування.
Архітектурно сервер складається із слоїв: представлення, бізнес-логіки, доступом до бази даних. Сервер додатків надає API за специфікацією REST API для забезпечення взаємодії з мобільним додатком, Front-частиною та IoT пристроям. Далі дані переходять до сервісів, які їх обробляють та за необхідністю вони переходять до репозиторіїв, які зберігають всю інформацію до бази даних. Цей сервер також відповідає за обробку запитів від клієнтських додатків та забезпечення безпеки даних.
Мобільний додаток є одним з ключових компонентів програмної системи і розглядається як клієнтська частина. Фізично додаток розгортається на мобільних пристроях кінцевих користувачів. Додаток доступний на платформі Android та містить гнучку архітектуру, яка складається із слоїв: представлення, абстракції та взаємодії із серверною частиною.  
 Коли користувач взаємодіє із додатком, то він працює із  представлення, яке підтримує логіку роботи графічних елементів. Потім він взаємодіє із шаром доступу до даних, який надсилає серверу запит за допомогою API, отримуючи та відправляючи дані для обробки. Формат даних для відправки JSON, а протокол HTTP.
Фронтенд є важливою частиною програмної системи, яка забезпечує інтерфейс для взаємодії із системою для адміністраторів готелю для тварин. Фізично фронтенд розгортається на веб-сервері та доступний через веб-браузер. Даний веб-сервер використовує фреймворк React, який дозволяє реалізувати графічні елементи для користувача, а також зв’язок із сервером.
 Шар взаємодії відповідає за обробку даних користувача. Він містить логіку, яка реагує на дії користувача та взаємодіє з іншими компонентами та сервером для отримання та відправлення даних. Компоненти це набір невеликих, самодостатніх частин фронтенду, які виконують конкретні функції. Компоненти можуть бути перевикористані та забезпечують модульність та підтримку масштабування. Шар інтерфейсу це верхній рівень, який відповідає за відображення інтерфейсу користувача. Він включає в себе всі візуальні елементи, такі як кнопки, форми, таблиці, графіки тощо, які користувач може бачити та з якими він може взаємодіяти.
Інтернет речей (IoT) пристрій є важливою складовою частиною програмної системи для контролю за тваринами у готелі. Фізично IoT пристрої встановлюються безпосередньо у приміщеннях готелю та забезпечують збір даних про тварин у реальному часі. Пристрій має можливість бездротового зв'язку з сервером мережею Інтернет для передачі зібраних даних, тому буде використовуватися також формат передачі даних JSON та протокол HTTP.
Архітектурно він буде складатися із двох частин, а саме контролерів, які будуть надавати інформацію про стан кімнати та тварини, а також сервіси, які отримують дані із контролерів та обробляють і надсилають їх на сервер.
Взаємодія між клієнтськими частинами системи та сервером проводяться за допомогою файлів у форматі JSON та протоколу передачі даних HTTP. Сервер містить контролери, які будуть приймати всі запити від інших компонентів систем.

3 ОПИС АРХІТЕКТУРИ СЕРВЕРНОЇ ЧАСТИНИ

Серверна частина була побудована згідно монолітної архітектури. Даний підхід до розробки програмного забезпечення називається монолітним, тому що весь додаток побудований як єдиний блок. Основна ідея полягає в тому, що всі компоненти програми, такі як інтерфейс користувача, бізнес-логіка та доступ до даних, розгортаються як один цілісний модуль. Вибір даного виду архітектури був викликаний особливостями проекту, оскільки в монолітній архітектурі немає необхідності в налаштуванні та керуванні різними сервісами, що дозволяє швидше розробляти та налаштовувати програму. 
Спираючись на широку практику побудови серверних частин, яка полягає у розбитті програми на кілька шарів, які відповідають за свою логіку, то розроблена серверна частина також містить декілька шарів: представлення, бізнес-логіка, шар доступу до даних, безпека. 
Шар представлення містить контролери, вони обробляють HTTP-запити від клієнтських частин, визначаючи шляхи та викликають відповідні сервіси для обробки запитів. Вони надають точку доступу для взаємодії із системою та містять доступ до основної функціональності системи, яка була реалізована. Для кожного типу користувачів передбачений власний контролер такий як: AuthenticationController, BusinesAdminController, DatabaseAdminController, UserController, DeviceController, PaymentController.
Сервіси містять бізнес-логіку системи. Вони виконують обчислення, валідацію та реалізацію об’єктів для комунікації між сервером, обробляючи запити від контролерів. Саме на цьому рівні відбувається зв’язок із зовнішніми API, такі як: Stripe API, Email API,  Dropbox API. Stripe API - це програмний інтерфейс, який надається компанією Stripe для взаємодії з їх платіжною системою. За допомогою Dropbox API  можна створювати різноманітні додатки, що потребують зберігання та обміну даними у хмарі. Даний API  використовується для зберігання фотографій користувачів та тварин.
Логіка реалізації процесу створення резервних копій для бази даних також знаходиться в шарі бізнес-логіки. Потрібно виділити, що інтерфейси сервісів та об’єкти для транспортування знаходяться на лінії під назвою “Domain”. Вона містить в собі всі необхідні деталі, щоб дозволити контролерам працювати, використовуючи інжекцію залежностей. Тобто контролери нічого не знають про конкретну реалізацію бізнес-логіки, а лише про задекларовані методи в інтерфейсах та об’єкти для передачі даних. Така структура дозволяє легко розширювати реалізації та змінювати зовнішні API. Щоб зменшити залежності від шару доступу до даних, був використаний механізм “Mapper”, який дозволив перетворювати сутності до об’єктів передачі даних і навпаки.
 Шар доступу до бази даних містить репозиторії та моделі. Репозиторії взаємодіють з базою даних та моделями, забезпечуючи доступ до даних та виконуючи операції, які пов’язані із видаленням, редагуванням, додаванням та зберіганням даних. Окрім стандартних методів репозиторію були створені додаткові запити, які формують спеціальний набір інформації для певного виду користувачів. Також додаткові методи для формування статистик. Для зменшення ризику виникнення помилок в частині, яка стосується роботи із базою даних були використані технології Java Persistence API (JPA) та Hibernate. Це технології , які використовуються для роботи з реляційними базами даних в Java-додатках. JPA є специфікацією для управління об'єктно-реляційною моделлю даних. Вона надає стандартний спосіб мапити Java-об'єкти на таблиці бази даних і навпаки. Hibernate є конкретною реалізацією специфікації JPA, також він є потужним фреймворком Object-Relational Mapping (ORM), який надає додаткові можливості порівняно з базовою специфікацією JPA. 
Моделі містять перелік об’єктів, які мають поля та методи для роботи із сутностями із бази даних.
Шар безпеки містить налаштування для фільтрації користувачів,  використовуючи Spring Security. Дана частина також містить файли конфігурації, які дозволяють правильно налаштувати роботу та перелік фільтрів, що забезпечить доступ для користувачів лише до певних контролерів. Також реалізований перехоплювач помилок (див. додаток А, пункт А.7). 
Файли фільтрів мають в собі логіку надання дозволу для запиту залежно від його адресу, а також вони визначають послідовність перевірок, які будуть здійснені для кожного запита. Автентифікація відбувається за допомогою токенів JWT, які формує сервер після авторизації в системі. Авторизація пристрою відбувається за допомогою API  ключа, який повинен міститися в запиті.

4 ПОБУДОВА ДІАГРАМИ ПРЕЦЕДЕНТІВ

Предметна область містить три типи користувачів на яких система має спиратися та реалізовувати свою функціональність залежно від потреб таких користувачів як клієнти, тобто власники тварин, адміністратор бази даних та адміністратор, який відповідає за бізнес-логіку системи. Кожен тип користувача має свій набір чітких функціональних потреб до продукту. 
Клієнт або власник тварини є основним типом користувача для даної предметної області, який повинен мати базові функції перегляду інформації та можливості з нею працювати та змінювати. Власник тварини може мати змогу переглянути інформацію про готелі, кімнати, обрати вільні кімнати, переглянути минулі оренди та поточні. Оскільки програмна система повинна мати певні способи монетизації, то клієнт зможе орендувати певну кімнату в певний період, щоб отримати доступ  до панелі контролю кімнати на період оренди. Така функціональність вимагає заповнення форми для надання інформаціє про тварину, номер картки, термін оренди. Зворотній зв’язок необхідний для користувача, щоб терміново повідомити про певні проблеми з його твариною. Перегляд власних тварин та їх додавання та редагування в системі, необхідна функція, щоб полегшити процес контролю та реєстрації тварини до системи. Кожен клієнт буде мати змогу редагувати свій власний профіль.
Описані функціональні потреби повністю характеризують необхідні функції для власника тварини та представленні у вигляді діаграми прецедентів (див. рис. 4.1).
Функціональні потреби адміністратора бази даних спираються на можливостях роботи бази даних та забезпечення цілісності даних, щоб керувати інформаційним змістом системи та сприяти її захисту. Даний вид адміністраторів має потребу переглядати всю інформацію, яка зберігається в системі про користувачів, тварин, оренди, кімнат та інші сутності, які наявні в системі. 
Оскільки адміністратор повинен не лише спостерігати за наявними даними, а й працювати з ними, тому він матиме потребу редагувати, видаляти, додавати різні види інформації. Бази даних зазвичай мають резервні копії, щоб уникнути ризику втрати інформації, тому функції резервного копіювання та відновлення системи після можливої аварії обов’язково мають бути в наявності даного адміністратора. Для візуалізації описаних функцій адміністратора бази даних було створено діаграму прецедентів для даного типу користувачів (див. рис. 4.2).
Останній вид користувачів це адміністратори бізнес-логіки програмної системи. Функціональні потреби даних адміністраторів спираються на контролі різних видів інформації та формування статистик, щодо роботи програмної системи загалом.  Всі функціональні потреби, які були описані для даного користувача,  представлені у вигляді діаграми прецедентів (див. рис. 4.3).
Даний вид адміністраторів буде мати можливість формувати статистику заробітку готелю в певний період часу, що дозволяє визначити доцільність витрат та стан певного готелю. Також присутня можливість визначати середню тривалість оренди кімнати, що дозволяє формувати нові бізнес-вимоги.
Система повинна надавати можливості реєстрації та автентифікації, оскільки дана функціональність характерна для всіх видів користувачів, то було прийняте рішення виділити даний функціонал на окремій діаграмі прецедентів (див. рис. 4.4).
Під час формування діаграм прецедентів було виділено основні види користувачів для даної програмної системи та їхній функціонал, який був описаний, а також представлений у вигляді діаграм прецедентів.

5 ПОБУДОВА ER-ДІАГРАМИ

Спираючись на моделювання предметної області була побудована ER- діаграма бази даних, яка враховує зберігання інформації для всієї представленої функціональності.
Спочатку було виділено основні стрижневі сутності, а саме: користувачі, тварини, готель, графік харчування. Потім для уникнення  зв’язків багато до багатьох були створенні проміжні та додаткові сутності для  повноцінного охоплення бізнес-логіки програми. Тобто було додано сутності  такі як кімната, оренда, кількість харчування.
Далі були визначені переліки атрибутів, що повинні мати сутності:
¾ користувач: користувач_id, пароль, електронна пошта, ПІБ, рік народження, вид користувача, номер телефону, посилання на фото. Первинний ключ: користувач_id ;
¾ тварина:  тварина_id, кличка, вік, вага, вид, опис, посилання на фото. Первинний ключ: тварина_id;
¾ готель: готель_id, назва, область, район, місто, вулиця, номер будинку. Первинний ключ: готель_id;
¾ кімната: кімната_id, номер, площа, ціна за 1 годину, IP, порт. Первинний ключ: кімната_id;
¾ оренда: оренда_id, початок оренди, кінець оренди. Первинний ключ: оренда_id;
¾ кількість харчування: харчування_id, порція, тип їжі. Первинний ключ: харчування_id;
¾ графік харчування: графік_id, дата та час. Первинний ключ: графік_id.
Визначивши сутності, атрибути між ними була побудована ER-діаграма реляційної бази даних (див. рис. 5.1).
Після виділення атрибутів для сутностей були позначенні зв’язки між 
ними враховуючи функціональні потреби користувачів системи:
¾ "користувач - тварина". Він має тип зв’язку “один до багатьох”, оскільки користувач може мати багато тварин, а тварина має лише одного власника;
¾ "готель - кімната". Він має тип зв’язку “один до багатьох”, оскільки готель може мати багато кімнат, а кімната належить одному готелю;
¾  "тварина - оренда". Він має тип зв’язку “один до багатьох”, оскільки тварина може мати багато оренд, а оренда кімнати може містити лише одну тварину;
¾ "кімната - оренда". Він має тип зв’язку “один до багатьох”, оскільки кімната може мати багато оренд, а оренда кімнати може містити лише одну кімнату;
¾ "оренда – кількість харчування". Він має тип зв’язку “один до багатьох”, оскільки оренда може мати багато видів харчування, а кількість харчування кімнати може належати лише одній оренді;
¾ "кількість харчування – графік харчування". Він має тип зв’язку “один до багатьох”, оскільки кількість належати багатьом графікам, а графік може належати лише одній кількості харчування.

6 СПЕЦИФІКАЦІЯ REST

REST (Representational State Transfer) - архітектурний стиль для розробки сучасних веб-додатків, який базується на стандартах протоколів HTTP. REST підтримує обмін даними між клієнтом і сервером шляхом використання ресурсів, ідентифікованих унікальними URL.
Серверна частина підтримує ресурси доступу до контролера авторизації, користувача, адміністраторів, пристроїв, оплати.
Контролер аутентифікації (див. додаток А, пункт А.1) відповідає за операції аутентифікації та авторизації користувачів у системі. Він надає можливість виконання таких операцій як увійти в систему, оновити токен доступу або зареєструвати нового користувача. Метод "Увійти в систему" (signIn),  доступний по адресу “/ /authentication/signIn”, приймає дані користувача та відповідає на них JWT-токенами для доступу та оновлення. Метод "Оновити токен" (refresh) ),  доступний по адресу “/authentication/refresh” дозволяє оновити токен доступу за допомогою токену оновлення. Це корисно для продовження строку дії токенів без необхідності повторного входу в систему. Метод "Зареєструвати користувача" (register) ),  доступний по адресу “/authentication/register”, дозволяє створити нового користувача у системі. Він приймає дані про нового користувача, такі як ім'я, електронну пошту та пароль, а також необов'язкове зображення користувача.
Контролер адміністрування бізнесу (див. додаток А, пункт А.2)  відповідає за адміністрування різних аспектів готельного бізнесу. Цей контролер надає доступ до різноманітних статистичних даних та функцій адміністрування готелю.
Метод "Середня тривалість оренди" (durationRenting) призначений для отримання середньої тривалості оренди приміщень у готелі. Він доступний за адресою “/businessAdmin/durationRenting” і приймає назву готелю як параметр запиту. Метод повертає список об'єктів AverageDurationRentingResponse, які містять статистичні дані щодо середньої тривалості оренди за певний період часу.
Метод "Дохід за період" (incomePeriod) доступний за адресою “/businessAdmin/incomePeriod” і дозволяє отримати звіт про дохід готелю за певний період часу. Він приймає назву готелю та дати початку і кінця періоду як параметри запиту та повертає список об'єктів IncomeResponse, які містять інформацію про дохід готелю за кожен день протягом вказаного періоду.
Так само, у контролері “BusinessAdmin” доступні методи для отримання списків користувачів, домашніх тварин, готелів, номерів, оренд, раціонів та розкладів. Кожен з цих методів приймає нуль параметрів та повертає список відповідних об'єктів даних.
Контролер адміністрування бази даних (див. додаток А, пункт А.3)  API відповідає за ряд функцій адміністрування бази даних готельного бізнесу.
Метод "Відновлення бази даних" (restore) доступний за адресою “/databaseAdmin/restore”. Цей метод використовується для відновлення бази даних з резервної копії. Він приймає масив байтів як тіло запиту, який містить хеш шляху до резервної копії бази.
Метод "Створення резервної копії бази даних" (backup) доступний за адресою “/databaseAdmin/backup”. Цей метод використовується для створення резервної копії бази даних. Він також приймає масив байтів з хешем шляху до резервної копії як тіло запиту.
Крім того, у контролері доступні методи для отримання списків користувачів, домашніх тварин, готелів, номерів, оренд, раціонів та розкладів. Кожен з цих методів приймає нуль параметрів та повертає список відповідних об'єктів даних.
Також реалізовані методи для додавання та видалення об'єктів, таких як користувачі, домашні тварини, готелі, номери, оренди, раціони та розклади. Ці методи приймають список відповідних об'єктів як тіло запиту.
“Device” контролер (див. додаток А, пункт А.5)   відповідає за взаємодію з пристроями у готельному середовищі. Він надає можливість отримання стану номерів, керування станом приміщень, відтворення відеопотоку та відправлення електронних листів користувачам.
Метод "Отримати стан номера" (getStateOfRoom) доступний за адресою “/device/{roomId}/state”. Цей метод приймає ідентифікатор номера як параметр у шляху і повертає стан вказаного номера.
Метод "Встановити новий стан номера" (setNewStateOfRoom) доступний за адресою “/device/{roomId}/setState”. Він встановлює новий стан для вказаного номера.
Метод "Оновити стан номера" (updateStateOfRoom) доступний за адресою “/device/{roomId}/updateState”. Він оновлює стан вказаного номера на основі наданого запиту.
Методи "Почати відеопотік" (startVideoStream) та "Зупинити відеопотік" (stopVideoStream) відповідають за початок і зупинку відеопотоку відповідно. Вони доступні за адресами “/device/{roomId}/startStream” та /device/{roomId}/stopStream.
Метод "Надіслати електронний лист користувачу" (sendEmailToUser) доступний за адресою “/device/{userId}/sendEmail”. Він надсилає електронний лист з вказаним повідомленням користувачу з вказаним ідентифікатором.
Метод "Отримати інформацію про оренду за датою та номером" (getRentingByDateAndRoom) доступний за адресою “/device/{roomId}/renting”. Він приймає ідентифікатор номера та дату як параметри та повертає інформацію про оренду.
Метод "Отримати інформацію про номер за IP-адресою" (getInfoRoomByIP) доступний за адресою “/device/room”. Він приймає IP-адресу як параметр та повертає інформацію про відповідний номер.
Контролер “PaymentController” (див. додаток А, пункт А.4)   відповідає за операції оплати через Stripe.
Метод "Створити платіжний намір" (createPaymentIntent) доступний за адресою “/payment/buy/card”. Цей метод використовується для створення платіжного наміру на основі отриманого запиту. Він приймає об'єкт StripeRequest у тілі запиту і повертає відповідь типу StripeResponse з інформацією про створений платіжний намір.
Обробка платежів здійснюється за допомогою сервісу Stripe, який інтегрований через інтерфейс StripeService.
Контролер “UserController” (див. додаток А, пункт А.6)   відповідає за взаємодію з обліковими записами користувачів та їх операціями у системі.
Метод "Отримати інформацію про користувача" (getPresentUser) доступний за адресою “/user/account/{email}”. Він приймає адресу електронної пошти користувача та повертає відповідну інформацію про користувача.
Метод "Отримати фото користувача" (getUserPhoto) доступний за адресою “/user/photo/{userId}”. Цей метод отримує ідентифікатор користувача та повертає фото користувача у форматі байтів.
Метод "Видалити користувача" (deleteUser) доступний за адресою “/user/account/{userId}/delete”. Він використовується для видалення облікового запису користувача.
Метод "Зберегти дані користувача" (saveUser) доступний за адресою “/user/account/save”. Він приймає дані користувача та фото у форматі MultipartFile і зберігає їх у системі.
Також у контролері реалізовані методи для отримання списку домашніх тварин користувача, історії оренди, списку готелів та номерів, а також для додавання нових оренд та надсилання повідомлень адміністратору.
Метод autogenerateSchedule призначений для автоматичної генерації розкладу оренди на основі отриманих даних оренди та кількості блоків. Він приймає об'єкт RentDto, що містить інформацію про оренду, та ціле число numberOfBlocks, яке вказує кількість блоків у розкладі. Після обробки метод повертає список об'єктів ScheduleFeedResponse, що містять інформацію про створені блоки розкладу.
Метод getScheduleFeed використовується для отримання розкладу оренди для вказаного орендного об'єкту. Він приймає ідентифікатор оренди (rentId) та повертає список об'єктів ScheduleFeedResponse, які представляють розклад оренди з вказаним ідентифікатором.
Метод updateTimeOfScheduleFeed призначений для оновлення часу розкладу оренди на основі отриманих даних. Він приймає список об'єктів ScheduleFeedResponse, що містять нові дані про час розкладу, та виконує оновлення в системі. Після успішного виконання метод повертає статус HTTP 200 (OK), а у випадку помилки - статус HTTP 404 (NOT FOUND).
 Доступ до ресурсів визначається за наявності JWT-токенів у запитах. Клієнт повинен передавати коректний токен доступу у заголовку запиту для отримання доступу до захищених ресурсів.
Управління помилками здійснюється за допомогою класу ExceptionHandler, який обробляє різноманітні типи помилок та повертає відповідні HTTP відповіді. Наприклад, використання класу MethodArgumentTypeMismatchException для помилок відповідності типів аргументів методу, MissingPathVariableException для відсутності шляхових змінних у запиті, MissingServletRequestParameterException для відсутності параметрів у запиті, та інші. Всі непередбачені помилки обробляються в останньому методі handleGenericException, який повертає відповідь з HTTP статусом INTERNAL_SERVER_ERROR та відповідним повідомленням про помилку.

7 ПОБУДОВА ДІАГРАМИ КОМПОНЕНТІВ

Побудова діаграми компонентів - це процес візуалізації архітектури програмної системи або проекту, розбитого на окремі компоненти та їх зв'язки.
Спочатку потрібно визначити всі компоненти системи. Компонент може бути будь-яким логічним або фізичним модулем, що виконує певну функцію. Оскільки програмна система складається із кількох програм, то можна виділити основні компоненти, такі як: серверна частина, база даних, мобільний застосунок, пристрій, Front-частина. Всі вони поділяються на певні логічні компоненти, які пов’язані між собою інтерфейсами та дозволяють розширювати систему.
Серверна частина містить в собі кілька логічних компонентів, а саме: доступ до даних (data), бізнес-логіка (business logic), представлення (presentation). Кожен із них виконує свою роботу в межах серверної частини. Потрібно виділити, що бізнес-логіка використовує компонент доступу до даних за допомогою інтерфейсів репозиторіїв. Тобто він використовує “IRepo” для комунікації. Також бізнес-логіка використовує зовнішні компоненти, такі як: Stripe API та Dropbox API. Компонент представлення використовує бізнес-логіку використовуючи інтерфейси сервісів “IService”. Сервер взаємодіє із базою даних, що також являє собою компонентом, використовуючи JDBC.
Мобільний застосунок взаємодіє із серверною частиною за допомогою  “IMobile”. Цей компонент також складається із декількох логічних компонентів, такі як: доступ до даних (data), абстракція (domain), представлення (presentation). Доступ до даних та представлення використовують абстракції використовуючи інтерфейси репозиторіїв.
Front-частина також взаємодіє із серверною частиною через протоколи HTTP. Даний компонент містить кілька логічних компонентів: Components, UI elements. Вони працюють один із одним через інтерфейси компонентів “IComponents”.
IoT пристрій відіграє роль фізичного компонента системи, який також взаємодія із сервером через мережеві протоколи. Згідно опису структури компонентів та їх взаємодії була побудована діаграма компонентів (див. рис. 7.1).
ВИСНОВКИ

Під час виконання лабораторної роботи була розроблена серверна частина програмної системи із необхідним функціональними потребами. 
Також були розроблені діаграми розгортання, компонентів, прецедентів та ER-діаграма бази даних. Були описані процеси побудови всіх UML діаграм, а також описана архітектура системи та наведена специфікація REST.

ДОДАТОК А
Специфікація REST

А.1 Контролер «AuthenticationController»

1 @RestController
2 @RequestMapping("/authentication")
3 public class AuthenticationController {
4
5     @Autowired
6     private AuthenticationService authenticationService;
7
8     @Autowired
9     private UserService userService;
10
11     @PostMapping("/signIn")
12     @Async
13     public ResponseEntity<JwtAuthenticationResponse> singIn(@RequestBody SignInRequest signInRequest) {
14         return ResponseEntity.ok(authenticationService.signIn(signInRequest));
15     }
16
17     @PostMapping("/refresh")
18     @Async
19     public ResponseEntity<JwtAuthenticationResponse> refresh(@RequestBody RefreshTokenRequest refreshTokenRequest) {
20         return ResponseEntity.ok(authenticationService.refreshToken(refreshTokenRequest));
21     }
22
23     @PostMapping("/register")
24     @Async
25     public ResponseEntity<Void> registerUser(@RequestBody UserDto user, @RequestBody MultipartFile file) {
26         if (userService.saveUser(user, file)) {
27             return new ResponseEntity<>(HttpStatus.OK);
28         } else {
29             return new ResponseEntity<>(HttpStatus.EXPECTATION_FAILED);
30         }
31     }
32 }

А.2 Контролер «BusinessAdminController»

1 @RestController
2 @RequestMapping("/businessAdmin")
3 public class BusinessAdminController {
4
5     @Autowired
6     private StatisticService statisticService;
7
8     @Autowired
9     private AdminService adminService;
10
11     @GetMapping("/durationRenting")
12     @Async
13     public ResponseEntity<List<AverageDurationRentingResponse>> getAverageDurationRenting(String nameHotel) {
14         return ResponseEntity.ok(statisticService.getAverageDurationRenting(nameHotel));
15     }
16
17     @GetMapping("/incomePeriod")
18     @Async
19     public ResponseEntity<List<IncomeResponse>> getIncomeDuringPeriodByHotel(String nameHotel, LocalDateTime beginDate, LocalDateTime endDate) {
20         return ResponseEntity.ok(statisticService.getIncomeDuringPeriodByHotel(nameHotel, beginDate, endDate));
21     }
22
23     @GetMapping("/allUsers")
24     @Async
25     public ResponseEntity<List<UserDto>> getAllUsers() {
26         return ResponseEntity.ok(adminService.getAllUsers());
27     }
28
29     @GetMapping("/allPets")
30     @Async
31     public ResponseEntity<List<PetDto>> getAllPets() {
32         return ResponseEntity.ok(adminService.getAllPets());
33     }
34
35     @GetMapping("/allHotel")
36     @Async
37     public ResponseEntity<List<HotelDto>> getAllHotels() {
38         return ResponseEntity.ok(adminService.getAllHotel());
39     }
40
41     @GetMapping("/allRoom")
42     @Async
43     public ResponseEntity<List<RoomDto>> getAllRooms() {
44         return ResponseEntity.ok(adminService.getAllRoom());
45     }
46
47     @GetMapping("/allRent")
48     @Async
49     public ResponseEntity<List<RentDto>> getAllRents() {
50         return ResponseEntity.ok(adminService.getAllRent());
51     }
52
53     @GetMapping("/allDiet")
54     @Async
55     public ResponseEntity<List<DietDto>> getAllDiets() {
56         return ResponseEntity.ok(adminService.getAllDiet());
57     }
58
59     @GetMapping("/allSchedule")
60     @Async
61     public ResponseEntity<List<ScheduleDto>> getAllSchedules() {
62         return ResponseEntity.ok(adminService.getAllSchedule());
63     }
64 }

А.3 Контролер «DatabaseAdminController»

1 @RestController
2 @RequestMapping("/databaseAdmin")
3 public class DatabaseAdminController {
4
5     @Autowired
6     private AdminService adminService;
7
8     @Autowired
9     private DatabaseService databaseService;
10
11     @PostMapping("/restore")
12     @Async
13     public ResponseEntity<Void> restoreDatabase(byte[] backupPathHash) {
14         if (databaseService.restoreDatabase(backupPathHash)) {
15             return new ResponseEntity<>(HttpStatus.OK);
16         } else {
17             return new ResponseEntity<>(HttpStatus.NOT_FOUND);
18         }
19     }
20
21     @PostMapping("/backup")
22     @Async
23     public ResponseEntity<Void> backupDatabase(byte[] backupPathHash) {
24         if (databaseService.doBackupDatabase(backupPathHash)) {
25             return new ResponseEntity<>(HttpStatus.OK);
26         } else {
27             return new ResponseEntity<>(HttpStatus.NOT_FOUND);
28         }
29     }
30
31     @GetMapping("/allUsers")
32     @Async
33     public ResponseEntity<List<UserDto>> getAllUsers() {
34         return ResponseEntity.ok(adminService.getAllUsers());
35     }
36
37     @GetMapping("/allPets")
38     @Async
39     public ResponseEntity<List<PetDto>> getAllPets() {
40         return ResponseEntity.ok(adminService.getAllPets());
41     }
42
43     @GetMapping("/allHotel")
44     @Async
45     public ResponseEntity<List<HotelDto>> getAllHotels() {
46         return ResponseEntity.ok(adminService.getAllHotel());
47     }
48
49     @GetMapping("/allRoom")
50     @Async
51     public ResponseEntity<List<RoomDto>> getAllRooms() {
52         return ResponseEntity.ok(adminService.getAllRoom());
53     }
54
55     @GetMapping("/allRent")
56     @Async
57     public ResponseEntity<List<RentDto>> getAllRents() {
58         return ResponseEntity.ok(adminService.getAllRent());
59     }
60
61     @GetMapping("/allDiet")
62     @Async
63     public ResponseEntity<List<DietDto>> getAllDiets() {
64         return ResponseEntity.ok(adminService.getAllDiet());
65     }
66
67     @GetMapping("/allSchedule")
68     @Async
69     public ResponseEntity<List<ScheduleDto>> getAllSchedules() {
70         return ResponseEntity.ok(adminService.getAllSchedule());
71     }
72
73     @PostMapping("/addUsers")
74     @Async
75     public  ResponseEntity<Void> addUsers(@RequestBody List<UserDto> users) {
76         if (adminService.addObject(users)) {
77             return new ResponseEntity<>(HttpStatus.OK);
78         } else {
79             return new ResponseEntity<>(HttpStatus.EXPECTATION_FAILED);
80         }
81     }
82
83     @PostMapping("/addPets")
84     @Async
85     public  ResponseEntity<Void> addPets(@RequestBody List<PetDto> petDtos) {
86         if (adminService.addObject(petDtos)) {
87             return new ResponseEntity<>(HttpStatus.OK);
88         } else {
89             return new ResponseEntity<>(HttpStatus.EXPECTATION_FAILED);
90         }
91     }
92
93     @PostMapping("/addHotels")
94     @Async
95     public  ResponseEntity<Void> addHotels(@RequestBody List<HotelDto> hotelDtos) {
96         if (adminService.addObject(hotelDtos)) {
97             return new ResponseEntity<>(HttpStatus.OK);
98         } else {
99             return new ResponseEntity<>(HttpStatus.EXPECTATION_FAILED);
100         }
101     }
102
103     @PostMapping("/addRooms")
104     @Async
105     public  ResponseEntity<Void> addRooms(@RequestBody List<RoomDto> roomDtos) {
106         if (adminService.addObject(roomDtos)) {
107             return new ResponseEntity<>(HttpStatus.OK);
108         } else {
109             return new ResponseEntity<>(HttpStatus.EXPECTATION_FAILED);
110         }
111     }
112
113     @PostMapping("/addRent")
114     @Async
115     public  ResponseEntity<Void> addRents(@RequestBody List<RentDto> rentDtos) {
116         if (adminService.addObject(rentDtos)) {
117             return new ResponseEntity<>(HttpStatus.OK);
118         } else {
119             return new ResponseEntity<>(HttpStatus.EXPECTATION_FAILED);
120         }
121     }
122
123     @PostMapping("/addDiet")
124     @Async
125     public  ResponseEntity<Void> addDiets(@RequestBody List<DietDto> dietDtos) {
126         if (adminService.addObject(dietDtos)) {
127             return new ResponseEntity<>(HttpStatus.OK);
128         } else {
129             return new ResponseEntity<>(HttpStatus.EXPECTATION_FAILED);
130         }
131     }
132
133     @PostMapping("/addSchedule")
134     @Async
135     public  ResponseEntity<Void> addSchedules(@RequestBody List<ScheduleDto> scheduleDtos) {
136         if (adminService.addObject(scheduleDtos)) {
137             return new ResponseEntity<>(HttpStatus.OK);
138         } else {
139             return new ResponseEntity<>(HttpStatus.EXPECTATION_FAILED);
140         }
141     }

А.4 Контролер «PaymentController»

1 @RestController
2 @RequestMapping("/payment")
3 public class PaymentController {
4
5     @Autowired
6     private StripeService stripeServiceImpl;
7
8     @PostMapping("/buy/card")
9     @Async
10     public ResponseEntity<StripeResponse> createPaymentIntent(@RequestBody StripeRequest request) {
11         return ResponseEntity.ok(stripeServiceImpl.createPaymentIntent(request));
12     }
13 }

А.5 Контролер «DeviceController»

1 @RestController
2 @RequestMapping("/device")
3 public class DeviceController {
4
5     @Autowired
6     private DeviceService deviceService;
7
8     @GetMapping("/{roomId}/state")
9     @Async
10     public ResponseEntity<StateOfRoomResponse> getStateOfRoom(@PathVariable int roomId) {
11         return ResponseEntity.ok(deviceService.getStateOfRoom(roomId));
12     }
13
14     @PostMapping("/{roomId}/setState")
15     @Async
16     public ResponseEntity<Void> setNewStateOfRoom(@PathVariable int roomId, @RequestBody StateOfRoomResponse stateOfRoomResponse) {
17         if (deviceService.setNewStateOfRoom(roomId, stateOfRoomResponse)) {
18             return new ResponseEntity<>(HttpStatus.OK);
19         } else {
20             return new ResponseEntity<>(HttpStatus.NOT_FOUND);
21         }
22     }
23
24     @PostMapping("/{roomId}/updateState")
25     @Async
26     public ResponseEntity<Void> updateStateOfRoom(@PathVariable int roomId, @RequestBody StateOfRoomRequest stateOfRoomRequest) {
27         if (deviceService.updateStateOfRoom(stateOfRoomRequest, roomId)) {
28             return new ResponseEntity<>(HttpStatus.OK);
29         } else {
30             return new ResponseEntity<>(HttpStatus.NOT_FOUND);
31         }
32     }
33
34     @GetMapping("/{roomId}/startStream")
35     @Async
36     public ResponseEntity<Mono<ServerResponse>> startVideoStream(@PathVariable int roomId) {
37         return ResponseEntity.ok(deviceService.startVideoStream(roomId));
38     }
39
40     @GetMapping("/{roomId}/stopStream")
41     @Async
42     public ResponseEntity<Mono<ServerResponse>> stopVideoStream(@PathVariable int roomId) {
43         return ResponseEntity.ok(deviceService.startVideoStream(roomId));
44     }
45
46     @PostMapping("/{userId}/sendEmail")
47     @Async
48     public ResponseEntity<Void> sendEmailToUser(@RequestBody String message, @PathVariable int userId) {
49         if (deviceService.sendEmailToUser(message, userId)) {
50             return new ResponseEntity<>(HttpStatus.OK);
51         } else {
52             return new ResponseEntity<>(HttpStatus.NOT_FOUND);
53         }
54     }
55
56     @GetMapping("/{roomId}/renting")
57     @Async
58     public ResponseEntity<RentDto> getRentingByDateAndRoom(@PathVariable int roomId, @RequestBody LocalDateTime dateTime) {
59         return ResponseEntity.ok(deviceService.getRentingByDateAndRoom(dateTime, roomId));
60     }
61
62     @GetMapping("/room")
63     @Async
64     public ResponseEntity<RoomDto> getInfoRoomByIP(@RequestBody String ip) {
65         return ResponseEntity.ok(deviceService.getInfoRoomByIP(ip));
66     }
67 }

А.6 Контролер «UserController»

1 @RestController
2 @RequestMapping("/user")
3 public class UserController {
4
5     @Autowired
6     private UserService userService;
7
8     @Autowired
9     private ScheduleService scheduleService;
10
11     @GetMapping("/account/{email}")
12     @Async
13     public ResponseEntity<UserDto> getPresentUser(@PathVariable String email) {
14         return ResponseEntity.ok(userService.findUserByEmail(email));
15     }
16
17     @GetMapping("/photo/{userId}")
18     @Async
19     public ResponseEntity<byte[]> getUserPhoto(@PathVariable int userId) {
20         return ResponseEntity.ok(userService.getUserPhoto(userId));
21     }
22
23     @PostMapping("/account/{userId}/delete")
24     @Async
25     public ResponseEntity<Void> deleteUser(@PathVariable int userId) {
26         if (userService.deleteUser(userId)) {
27             return new ResponseEntity<>(HttpStatus.OK);
28         } else {
29             return new ResponseEntity<>(HttpStatus.NOT_FOUND);
30         }
31     }
32
33     @PostMapping("/account/save")
34     @Async
35     public ResponseEntity<Void> saveUser(@RequestBody UserDto user, @RequestBody MultipartFile photo) {
36         if (userService.saveUser(user, photo)) {
37             return new ResponseEntity<>(HttpStatus.OK);
38         } else {
39             return new ResponseEntity<>(HttpStatus.NOT_FOUND);
40         }
41     }
42
43     @GetMapping("/{userId}/listOfPets")
44     @Async
45     public ResponseEntity<List<PetDto>> getPetsOfUser(@PathVariable int userId) {
46         return ResponseEntity.ok(userService.getListOfPets(userId));
47     }
48
49     @PostMapping("/addPets")
50     @Async
51     public ResponseEntity<Void> addPetsOfUser(@RequestBody List<PetDto> pets) {
52         if (userService.addPets(pets)) {
53             return new ResponseEntity<>(HttpStatus.OK);
54         } else {
55             return new ResponseEntity<>(HttpStatus.NOT_FOUND);
56         }
57     }
58
59     @GetMapping("/{userId}/historyRenting")
60     @Async
61     public ResponseEntity<List<HistoryRentingResponse>> getHistoryRenting(@PathVariable int userId) {
62         return ResponseEntity.ok(userService.getHistoryRenting(userId));
63     }
64
65     @GetMapping("/hotels")
66     @Async
67     public ResponseEntity<List<HotelDto>> getAllHotels() {
68         return ResponseEntity.ok(userService.getAllHotels());
69     }
70
71     @GetMapping("/hotels/{hotelId}/rooms")
72     @Async
73     public ResponseEntity<List<RoomDto>> getRoomsByHotel(@PathVariable int hotelId) {
74         return ResponseEntity.ok(userService.getAllRoomsByHotel(hotelId));
75     }
76
77     @PostMapping("/addNewRenting")
78     @Async
79     public ResponseEntity<Void> addNewRentingForUser(@RequestBody List<ScheduleDto> scheduleDtoList) {
80         if (userService.addNewRentingForUser(scheduleDtoList)) {
81             return new ResponseEntity<>(HttpStatus.OK);
82         } else {
83             return new ResponseEntity<>(HttpStatus.NOT_FOUND);
84         }
85     }
86
87     @GetMapping("/hotels/{hotelId}/freeRooms")
88     @Async
89     public ResponseEntity<List<RoomDto>> getAllFreeRoomByPeriod(@PathVariable int hotelId, LocalDateTime beginDate, LocalDateTime endDate) {
90         return ResponseEntity.ok(userService.getAllFreeRoomByPeriod(hotelId, beginDate, endDate));
91     }
92
93     @PostMapping("/{userId}/feedback")
94     @Async
95     public ResponseEntity<Void> sendMessageToAdmin(@PathVariable int userId, @RequestBody String message) {
96         if (userService.sendMessageToAdmin(userId, message)) {
97             return new ResponseEntity<>(HttpStatus.OK);
98         } else {
99             return new ResponseEntity<>(HttpStatus.NOT_FOUND);
100         }
101     }
102
103     @GetMapping("/rent/autogenerateSchedule")
104     @Async
105     public ResponseEntity<List<ScheduleFeedResponse>> autogenerateSchedule(@RequestBody RentDto rentDto, @RequestBody int numberOfBlocks) {
106         return ResponseEntity.ok(scheduleService.autogenerateSchedule(rentDto, numberOfBlocks));
107     }
108
109     @GetMapping("/rent/schedule")
110     @Async
111     public ResponseEntity<List<ScheduleFeedResponse>> getScheduleFeed(@RequestBody int rentId) {
112         return ResponseEntity.ok(scheduleService.getScheduleFeed(rentId));
113     }
114
115     @PostMapping("/rent/updateSchedule")
116     @Async
117     public ResponseEntity<Void> updateTimeOfScheduleFeed(@RequestBody List<ScheduleFeedResponse> scheduleFeedResponses) {
118         if (scheduleService.updateTimeOfScheduleFeed(scheduleFeedResponses)) {
119             return new ResponseEntity<>(HttpStatus.OK);
120         } else {
121             return new ResponseEntity<>(HttpStatus.NOT_FOUND);
122         }
123     }
124 }


А.7 Перехоплювач помилок “ExceptionHandler”


1 @ControllerAdvice
2 public class ExceptionHandler {
3
4 /**
5 * Handles MethodArgumentTypeMismatchException by returning a BAD_REQUEST response.
6 * @param ex The MethodArgumentTypeMismatchException that occurred.
7 * @return ResponseEntity with error message and HTTP status BAD_REQUEST.
8 */
9 @org.springframework.web.bind.annotation.ExceptionHandler(org.springframework.web.method.annotation.MethodArgumentTypeMismatchException.class)
10 public ResponseEntity<String> handleMethodArgumentTypeMismatch(org.springframework.web.method.annotation.MethodArgumentTypeMismatchException ex) {
11 String error = ex.getName() + " should be of type " + ex.getRequiredType().getName();
12 return new ResponseEntity<>(error, HttpStatus.BAD_REQUEST);
13 }
14
15 /**
16 * Handles MissingPathVariableException by returning a BAD_REQUEST response.
17 * @param ex The MissingPathVariableException that occurred.
18 * @return ResponseEntity with error message and HTTP status BAD_REQUEST.
19 */
20 @org.springframework.web.bind.annotation.ExceptionHandler(org.springframework.web.bind.MissingPathVariableException.class)
21 public ResponseEntity<String> handleMissingPathVariable(org.springframework.web.bind.MissingPathVariableException ex) {
22 String error = ex.getMessage();
23 return new ResponseEntity<>(error, HttpStatus.BAD_REQUEST);
24 }
25
26 /**
27 * Handles MissingServletRequestParameterException by returning a BAD_REQUEST response.
28 * @param ex The MissingServletRequestParameterException that occurred.
29 * @return ResponseEntity with error message and HTTP status BAD_REQUEST.
30 */
31 @org.springframework.web.bind.annotation.ExceptionHandler(org.springframework.web.bind.MissingServletRequestParameterException.class)
32 public ResponseEntity<String> handleMissingServletRequestParameter(org.springframework.web.bind.MissingServletRequestParameterException ex) {
33 String error = ex.getMessage();
34 return new ResponseEntity<>(error, HttpStatus.BAD_REQUEST);
35 }
36
37 /**
38 * Handles HttpRequestMethodNotSupportedException by returning a METHOD_NOT_ALLOWED response.
39 * @param ex The HttpRequestMethodNotSupportedException that occurred.
40 * @return ResponseEntity with error message and HTTP status METHOD_NOT_ALLOWED.
41 */
42 @org.springframework.web.bind.annotation.ExceptionHandler(org.springframework.web.HttpRequestMethodNotSupportedException.class)
43 public ResponseEntity<String> handleHttpRequestMethodNotSupported(org.springframework.web.HttpRequestMethodNotSupportedException ex) {
44 String error = ex.getMessage();
45 return new ResponseEntity<>(error, HttpStatus.METHOD_NOT_ALLOWED);
46 }
47
48 /**
49 * Handles any other exception by returning an INTERNAL_SERVER_ERROR response.
50 * @param ex The exception that occurred.
51 * @return ResponseEntity with error message and HTTP status INTERNAL_SERVER_ERROR.
52 */
53 @org.springframework.web.bind.annotation.ExceptionHandler(Exception.class)
54 public ResponseEntity<String> handleGenericException(Exception ex) {
55 return new ResponseEntity<>("An unexpected error occurred: " + ex.getMessage(), HttpStatus.INTERNAL_SERVER_ERROR);
56 }
57 }
